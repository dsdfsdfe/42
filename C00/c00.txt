///

vs code 편하게 사용할 수 있는 몇가지 설정들이에요!
1. 42 Header 익스텐션 다운로드 
커맨드+알트+H 로 헤더 작성
User setting 에서 42header:Email, 42header:Username 설정 후 사용
2. Norminette-42 익스텐션
norminette 에러들을 빨간 줄로 표시해줍니다
** indentation/ white space 설정하는 팁
Setting 들어가기
Editor >. Tab size 4로 설정
Editor > insert spaces : false 로 설정
Editor > render white spaces : all 로 설정
Files > trim trailing whitespace : 	true 설정
Files > insert final new line : true 설정

///

:Stdheader


** Main 함수를 작성해야함 -> 코드를 실행하기 위하여

#include :: ~를 포함하라는 의미의 전처리기. 즉 #include <stdio.h> 는 stdio.h를 포함한다는 뜻
ㅡ옵션
<stdio.h> :: standard input output의 약자. h는 header의 약자. C 언어의 표준 라이브러리 함수의 매크로 정의, 상수, 여러 형의 입출력 함수가 포함된 헤더 파일
<stdlib.h> :: C 언어의 표준 라이브러리로 n문자열 변환, 의사 난수 생성, 동적 메모리 관리 등의 함수들을 포함
<unistd.h> :: 유닉스에서 사용하는 C 컴파일러 헤더파일. window에서는 사용하지 않는다
<string.h> :: C 언어의 표준 라이브러리 메모리 블록이나 문자열을 다룰 수 있는 함수 포함
<strings.h> ::  C 형식 문자열 (널 종료 문자열) 을 다룰 수 있는 함수 포함
<fcntl.h> :: file control 함수 조회와 설정을 할 수 있는 함수
<stdbool.h> :: bool, true, false를 그대로 쓸 수 있다


Ex00

1. #include <unistd.h> 입력
2. 프로토 타입 선언(묶어준다) write 함수 사용한 뒤 return(0);으로 종료

write :: 
return(0); :: 실행중인 함수를 벗어난다

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Ex01

1. ft_putchar 함수를 사용할 것이므로(write 출력 위해) 위에 써줌
2. 문자열 사용 ㅡ char 형태의 abc(문자열 이름)를 생성
2. 알파벳 'a'의 바이트에서 각각 1씩 추가하면 b,c,d...가 된다. 따라서 abc가 'z'보다 이하일때까지 abc를 출력 후 바이트를 1씩 추가

while :: 조건에 만족하는 동안 반복

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Ex02

1. ex01과 방식은 똑같지만 바이트를 1씩 뺀다. 그럼 z부터 시작해서 a까지 출력 가능

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Ex03

1. ex01과 동일, 알파벳 대신 숫자 입력(문자로 출력할 것이기에 따옴표로 묶어준다)

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Ex04

1. if문 사용, n이 0보다 작을(음수)때는 N 양수일때는 P를 출력하도록 한다

조건문(if ~else) :: 조건에 맞는 결과만 출력

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Ex05

1. char 형태의 a b c를 생성, while문을 이용
2. a는 ex 0++(결과 1)에서 시작 > ++a가 9이하일 동안 b=a로 정의 후 ++b(ex 2)가 9 이하일 동안 > c=b+1(ex 3)로 넘어감 > 'a''b''c' 출력하고
3. a가 7이 아니거나 b가 8, c가 9가 아닐때 ', '를 출력. c에 1을 더하고 조건을 벗어날 때까지 반복한다 / a,b,c가 모두 7,8,9라면? ', '를 출력하지 않는다

:: a가 -1이면? -> 동작 안함 / a가 0이면? -> 1부터 시작. 이유는? ++(1추가)가 붙어있기 때문이다
:: ++c를 아래에 쓰는 이유는? -> 위에 추가하면 동작할때 1이 추가되어서 앞자리 수가 6까지밖에 안나옴
:: 퓨쳐 함수에 ', '을 안쓰고 따로 쓰는 이유 -> 바이트 제한

|| :: or 하나라도 참이면 조건 충족
&& :: and 모두 참이어야 함, 하나라도 거짓이면 불충족
! :: not 논리부정 연산자. 거짓>참 참>거짓 / "!="는 같지 않다 라는 의미

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Ex06

1. // 먼저 ft_print_2로 인자를 빼놓는다(하나에 넣어도 되지만 복잡하니까) > a를 10으로 나눈 몫에 '0'을 더하고(48을 더해도 상관없음) + a를 10으로 나눈 나머지에 0을 더하고 + 공백 + b를 10으로 나눈 몫에 0을 더하고 + b를 10으로 나눈 나머지에 0을 더한 것을 출력. if a가 98이 아닐때 ', '을 출력한다 //
2. ft_print_comb2에서 int a와 b를 사용한다고 선언
3. a는 00, b는 00으로 시작한다. a가 100 미만(99)일 동안 while문이 돌아간다
4. b=a+1로 정의, b가 100 이하(99)일 동안 이중 while사용. a, b를 출력하고 b에 1을 더한다 > 빠져나와서 a에 1을 더한다
5. 조건을 벗어날때까지 반복

/ :: 산술연산자. 왼쪽의 피연산자를 오른쪽의 피연산자로 나눔
% :: 산술연산자. 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환

<같이 보면 좋은 연산자>

+ :: 왼쪽의 피연산자에 오른쪽의 피연산자를 더함
- :: 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌
* :: 왼쪽의 피연산자에 오른쪽의 피연산자를 곱함

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Ex07

1. 먼저 문자로 출력할 거니까 퓨처 함수 선언
2. 조건문/ 입력값이 int 최소값일때 = 입력값 그대로는 출력불가. 10으로 나눈 몫을 먼저 출력후 끝자리에 8을 붙인다
3. 조건문/ 입력값이 음수일때 = 음수 그대로는 출력 오류나므로(양수와 음수의 형태가 다름) 양수로 전환 후 -기호를 붙인다
4. 조건문/ 입력값이 10 이상일때 = ex)123이라면, 먼저 10의 자리로 나누어서 12는 재귀함수로 반환하는 동시에 123을 10으로 나눈 나머지인 3을 출력하나, 함수가 먼저 호출되면 미루어진다(순서를 바꾸면 역순출력) :: 함수가 끝났을때 차례대로 하나씩 반복되었던 재귀함수가 반환되면서 퓨처값도 차례대로 출력된다

:: ft_putnbr(nb);로 하지 않는 이유? > 이렇게 하지 않으면 -2147483648을 넣었을때 오류남. 그래서 10으로 나눈 몫(소숫점은 출력x 214748364)를 출력 후 8을 이어주는것
:: 음수를 그대로 출력하지 않고 양수로 바꾼 후 '-' 기호를 붙여주는 이유는? > 음수 그대로 출력하면 오류남. c언어의 음수는 양수와 달리 2의 보수 형태로 처리됨, 따라서 양수처럼 출력하고 싶을때에는 양수로 전환한뒤 - 기호를 붙여야한다
:: n % 10를 하는 이유는? 다른 조건문 예외처리를 위해서

int형 변수 :: -2147483648 ~ 2147483647 까지의 값 출력 가능
문자 '0'이 시작하는 위치의 정수값은 48. 그래서 각 숫자에 48을 더하면 &c로 숫자를 출력 가능

:: 왜 인자가 10 이상이면 10으로 나눈 몫을 반환하는가? > 아스키코드로 숫자 출력은 48(0)~57(9)까지. 인자가 9 이하일 경우엔 문제가 없지만 그 이상을 바로 출력하면 엉뚱한 값이 나오기 때문에 인자가 9 초과일 때는 하나씩 따로 출력해야한다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Ex08